import { LocalSolanaMigrate } from '../target/types/local_solana_migrate';
import * as anchor from '@coral-xyz/anchor';
import { Program, AnchorProvider, web3, BN } from '@coral-xyz/anchor';
import { PublicKey, SystemProgram, Keypair } from '@solana/web3.js';
import { assert,expect } from 'chai';

describe('local_solana_migrate', () => {
  const provider = AnchorProvider.local();
  anchor.setProvider(provider);

  const program = anchor.workspace.LocalSolanaMigrate as Program<LocalSolanaMigrate>;

  let seller: Keypair;
  let buyer: Keypair;
  let escrowPda: PublicKey;
  let escrowStatePda: PublicKey;
  let bump: number;

  const orderHash = new BN(123456);
  const orderHashBuffer = orderHash.toArrayLike(Buffer,'le',32);

  before(async () => {
    seller = Keypair.generate();
    buyer = Keypair.generate();

    const [escrowStatePda_, escrowStateBump] = PublicKey.findProgramAddressSync(
      [Buffer.from('escrow_state'), seller.publicKey.toBuffer()],
      program.programId
    );
    escrowStatePda = escrowStatePda_;
    console.log("Escrow State:: " + escrowStatePda);
    console.log("Escrow State Bump:: " + escrowStateBump);

    const [escrowPda_, escrowBump] = PublicKey.findProgramAddressSync(
      [Buffer.from('escrow'), orderHashBuffer],
      program.programId
    );
    escrowPda = escrowPda_;
    bump = escrowBump;

    console.log("Escrow PDA:: " + escrowPda);
    console.log("Escrow Bump:: " + escrowBump);

    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(seller.publicKey, 10 * web3.LAMPORTS_PER_SOL),
      'confirmed'
    );
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(buyer.publicKey, 10 * web3.LAMPORTS_PER_SOL),
      'confirmed'
    );
  });

  it("Initializes escrow state", async () => {
    try {
      await program.rpc.initialize(
        new BN(50), 
        new BN(1000000), 
        PublicKey.default, 
        {
          accounts: {
            seller: seller.publicKey,
            arbitrator: PublicKey.default,
            feeRecipient: PublicKey.default,
            deployer: seller.publicKey,
            escrowState: escrowStatePda,
            systemProgram: SystemProgram.programId,
          },
          signers: [seller],
        }
      );
      console.log('Escrow state initialized');
      const escrowState = await program.account.escrowState.fetch(escrowStatePda);
      expect(escrowState.seller.toBase58()).to.equal(seller.publicKey.toBase58());
  
    } catch (err) {
      console.error('Error initializing escrow state:', err);
      throw err;
    }
  });

  it('Creates an escrow for SOL transfer', async () => {
    
    try {
      await program.rpc.createEscrowSol(
        orderHashBuffer,
        new BN(6 * web3.LAMPORTS_PER_SOL), 
        new BN(3600), 
        {
          accounts: {
            escrowState: escrowStatePda,
            escrow: escrowPda,
            seller: seller.publicKey,
            buyer: buyer.publicKey,
            systemProgram: SystemProgram.programId,
            partner: PublicKey.default,
          },
          signers: [seller],
        }
      );
      console.log('Escrow created');
      const escrow = await program.account.escrow.fetch(escrowPda);
      expect(escrow.amount.toNumber()).to.equal(6 * web3.LAMPORTS_PER_SOL);
    } catch (err) {
      console.error('Error creating escrow:', err);
      throw err;
    }
  });

  it('Marks escrow as paid', async () => {
    try {
      const escrowInfo = await program.account.escrow.fetch(escrowPda);
     console.log('escrowInfo:'+escrowInfo.sellerCanCancelAfter);
      await program.rpc.markAsPaid(orderHash.toArray(), {
        accounts: {
          escrowState: escrowStatePda,
          escrow: escrowPda,
          buyer: buyer.publicKey,
          seller: seller.publicKey,
        },
        signers: [buyer],
      });
      const escrow = await program.account.escrow.fetch(escrowPda);
      expect(escrow.sellerCanCancelAfter).to.equal(1);
    } catch (err) {
      console.error("Error marking escrow as paid:", err);
      throw err;
    }
  });

  it('Releases funds to buyer', async () => {
    
    try {
      await program.rpc.releaseFunds(orderHashBuffer, {
        accounts: {
          escrowState: escrowStatePda,
          escrow: escrowPda,
          seller: seller.publicKey,
          buyer: buyer.publicKey,
          escrowTokenAccount: PublicKey.default,  // Not used for SOL
          buyerTokenAccount: PublicKey.default,  // Not used for SOL
          tokenProgram: PublicKey.default,
        },
        signers: [seller],
      });
      console.log("Funds released to buyer");
    } catch (err) {
      console.error("Error releasing funds:", err);
      throw err;
    }
  });

  it('Fetches seller account balance', async () => {
    const balance = await provider.connection.getBalance(seller.publicKey);
    console.log("Seller balance:", balance);
    assert(balance > 0, "Seller should have a positive balance");
  });

  it('Fetches buyer account balance', async () => {
    const balance = await provider.connection.getBalance(buyer.publicKey);
    console.log("Buyer balance:", balance);
    assert(balance > 0, "Buyer should have a positive balance");
  });
});
